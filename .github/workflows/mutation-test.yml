name: Mutation Testing & Rickroll

on:
  push:
    branches: [ '**' ]      # Allow all branches be triggered
  pull_request:
    branches: [ '**' ]      

jobs:
  mutation-testing:
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout the repository code
      - uses: actions/checkout@v4

      # 2. Set up JDK 17 (Standard for GraphHopper)
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      # 3. Download Previous Score (Design Choice: Persistence)
      # We use 'dawidd6/action-download-artifact' because standard actions cannot 
      # download artifacts from *previous* workflow runs, only the current one.
      - name: Download previous mutation score
        id: download_score
        uses: dawidd6/action-download-artifact@v6
        with:
          name: mutation-score-report
          path: previous_data/
          if_no_artifact_found: warn # Start fresh if no history exists
          search_artifacts: true     # Search in previous successful runs

      # 4. Run PITest on web-bundle module only
      # We limit to web-bundle to save time. Configuration is in pom.xml.
      - name: Run PITest (Mutation Testing)
        run: |
          mvn -pl web-bundle org.pitest:pitest-maven:mutationCoverage

      # 5. Compare Scores and Fail if Dropped (TÃ¢che 1)
      - name: Check Mutation Score
        id: check_score
        run: |
          echo "Analyzing Mutation Score..."
          
          # Path to the generated XML report
          REPORT_PATH="web-bundle/target/pit-reports/mutations.xml"
          
          if [ ! -f "$REPORT_PATH" ]; then
            echo "Error: PITest report not found at $REPORT_PATH"
            exit 1
          fi

          # Extract mutation coverage percentage using regex from XML
          # Looks for: mutationCoverage="XX"
          CURRENT_SCORE=$(grep -oP 'mutationCoverage="\K[0-9]+' "$REPORT_PATH" | head -1)
          
          echo "Current Mutation Score: $CURRENT_SCORE%"

          # Retrieve previous score (default to 0 if first run)
          PREV_SCORE=0
          if [ -f previous_data/score.txt ]; then
            PREV_SCORE=$(cat previous_data/score.txt)
          fi
          
          echo "Previous Mutation Score: $PREV_SCORE%"

          # Save current score for the NEXT run (before we potentially fail)
          echo "$CURRENT_SCORE" > score.txt

          # Logic: Fail if current score is strictly less than previous score
          if (( CURRENT_SCORE < PREV_SCORE )); then
            echo "::error::Mutation score dropped from $PREV_SCORE% to $CURRENT_SCORE%!"
            exit 1
          else
            echo "Mutation score is stable or improved ($CURRENT_SCORE% >= $PREV_SCORE%). Good job!"
          fi

      # 6. Upload Current Score as Artifact (Persistence)
      # "always()" ensures this runs even if the test failed, 
      # but logically we only want to update the baseline if we decide that is the policy.
      # Here we upload it so the next run knows the latest state.
      - name: Save mutation score
        if: always() 
        uses: actions/upload-artifact@v4
        with:
          name: mutation-score-report
          path: score.txt
          overwrite: true

      # 7. Rickroll on Failure (TÃ¢che 5)
      # This step only runs if any previous step failed (if: failure())
      - name: Rickroll Payload
        if: failure()
        run: |
          echo "=================================================="
          echo "ðŸš« BUILD FAILED! YOU KNOW THE RULES, AND SO DO I ðŸš«"
          echo "=================================================="
          echo "ðŸŽµ Never gonna give you up"
          echo "ðŸŽµ Never gonna let you down"
          echo "ðŸŽµ Never gonna run around and desert you"
          echo "=================================================="
          echo "Open for a surprise: https://www.youtube.com/watch?v=dQw4w9WgXcQ"